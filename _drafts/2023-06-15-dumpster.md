---
layout: post
title: "Building a garbage collector for a language that doesn't need one"
date: 2023-06-15 15:45:35 -0500
tags: rust
---

If carcinization is what happens when languages evolve to be more like Rust, then what do you call
it when Rust evolves to be more like Java? Caffeination?

{% include mermaid.html %}
{% include mathjax.html %}

Over this summer, I've had a decent amount of time to kill.
What better way to spend a beatiful hot summer than sitting inside, staring at core dumps in a
supposedly memory safe language?
I build a garbage collector - in short, a piece of software that manages allocations for another,
more exciting piece of software.
The more exciting part: I made it in Rust, for Rust - a language designed to eliminate garbage
collection and which provides few facilities for making it work properly.
Not only that, I managed to make my garbage collector work with relatively few compromises, which
I'll describe in further detail lower down.

## Background

If you're familiar with the details of Rust and its standard library, feel free to skip this
section.

The core backing behind Rust's memory model is _affine typing_ and the _borrow checker_.
Values may only be bound to one identifier at a time, and borrows (a.k.a. references) may not outlive
the scope binding their referent.

For example, the following code is invalid:

```rust
let x = vec![1, 2, 3];
let y = x;
println!("{x:?}"); // compile error - x has already been moved
```

Normally, we work around this by borrowing against a binding, such as by making `y = &x` in the
example above.
However, we often need to share some heap-allocated value without knowing which binding will live
the longest.
The solution to this problem is shared ownership via garbage collection.

Rust's standard library offers two simple reference-counted garbage collectors: the single-threaded
[`Rc`](https://doc.rust-lang.org/std/rc/index.html) and its atomically-indexed counterpart
[`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html).
They operate by maintining a reference count in each heap allocation.
Under most circumstances, these work great, but they can't handle cyclic references.
Combined with interior mutability, it's trivial to refute them.

```rust
use std::{cell::OnceCell, rc::Rc};
struct Foo(OnceCell<Rc<Foo>>);

let x = Rc::new(Foo(OnceCell::new()));
x.0.set(Rc::clone(&x));
// My foo has a reference to itself. It can never be freed!
```

This is why people actually get paid money to build garbage collectors.
If using a reference counter were all you needed, a number of people working at Oracle would be out
of a job.

## Battle plan

We'd like to create some `Gc` data structure with a similar API to `Rc` and `Arc`, which can accept
nearly any data type contained within, and still manage to detect and collect cycles.

We have a few weapons at our disposal:

- **`Drop`**: Every non-copiable data type in Rust can implement the `Drop` trait to ensure some
  code is called every time it is dropped.
  In our case, we can implement `Drop` for `Gc` to try to glean some knowledge about when an
  allocation becomes inaccessible.
- **Traits**: We can construct some trait (in our case, let's call it `Collectable`) as a mandatory
  requirement to be contained in a `Gc`.
  Creating this trait has some major downsides (libraries upstream of `dumpster` can't implement it)
  but it's a necessary evil.

However, our formidable tools are matched by equally formidable challenges:

- **Undetectable moves**. When a value is moved in Rust, there is no way to detect that fact from
  within that value.
  If we had some sort of trait like `OnMove` which could allow for a function to be called every
  time it had moved, we could use it to detect when a `Gc` moved inside another `Gc`, making it
  unrooted, and allowing us to create a simple mark-sweep collector.
- **Variable-sized data**. I foolishly decided to make it so that `Gc` could store `?Sized` types,
  which is more flexible for library users (enabling things like `Gc<dyn MyTrait>` and `Gc<[T]>`.
- **Type erasure**. In a typical Rust program, generics are implemented via monomorphization, and
  no type information is retained at runtime.
  This makes it harder to effectively clean up an allocation once it's done.

With these two, relatively simple tools, we have enough to build a collector which can handle just
about any data type inside.

## My approach

We need to be able to detect whether a `Gc` is reachable without actually scanning the stack.
I'll start with a few definitions, using graph-theoretical language.

1. An allocation graph \\(G = (V, E, r)\\) is a directed graph equipped with a root node \\(r\\),
   whose indegree is zero.
1. A node \\(v\\) in an allocation graph is said to be _accessible_ if and only if there exists a
   path from \\(r\\) to \\(v\\) in the graph.

It should be clear to see why these definitions are useful to us.
We can imagine each node being one allocation, pretending that all data not indirected through a
`Gc` is part of an imaginary allocation for the root.
Additionally, each `Gc` acts as an edge connecting the allocation containing it to the allocation it
points to.
If an allocation is accessible in the graph-theoretical sense, it's still possible for a program to
reach it, and if not, it's safe to free that allocation.
Note that the indegree of a node is exactly equal to the reference count of its corresponding
allocation.

I'll roughly outline our approach to determining whether some node \\(n: \neq r\\) is accessible:

1. Find \\(W\\), the set of all descendants \\(n\\).
   Construct the subgraph \\(H\\) of \\(G\\) whose vertex set is \\(W\\), preserving all edges
   from \\(W\\) to \\(W\\).
1. Find the set of nodes \\(A \subseteq W\\) for which the indegree of each \\(a \in A\\) in \\(H\\)
   is _not_ equal to its indegree in \\(G)\\.
1. For each \\(a \in A\\), mark it and its descendants as accessible.
1. If an only if \\(n\\) was marked as accessible, it is accessible.

Here's a serpentine implementation in pseudocode, if that's what you prefer:

```py
def accessible(n):
    counts = {n: n.indegree()}
    for (_, m) in n.edges():
        dfs(m, counts)

    reachable = set()
    for (a, count) in counts:
        if count == 0:
            sweep(a, reachable)

    return n in reachable


def dfs(n, counts):
    if n not in counts:
        counts[n] = n.indegree()
        for (_, m) in n.edges():
            dfs()

    counts[n] -= 1

def sweep(a, reachable):
    if a not in reachable:
        reachable.add(a)
        for (_, b) in a.edges():
            sweep(b)
```

It should be pretty clear to see that `accessible` runs in \\(O(\|V\| + \|E\|)\\) time.

## `Rc` with extra steps

Our single-threaded `Gc` will behave a lot like an `Rc`, but with some small details changed.

First, we define a `Gc` and the allocation it points to, a `GcBox`:

```rust
pub struct Gc<T: ?Sized> {
    ptr: NonNull<GcBox<T>>
}

struct GcBox<T: ?Sized> {
    ref_count: Cell<usize>,
    value: T
}
```

We can then hook into the `Drop` behavior for our `Gc` to make it all work:

```rust
impl<T: ?Sized> Drop for Gc<T> {
    fn drop(&mut self) {
        unsafe {
            let box_ref = self.ptr.as_ref();
            match box_ref.ref_count.get() {
                0 => (),
                n => {
                    box_ref.ref_count.set(n - 1);
                    if n == 1 || !is_accessible(box_ref) {
                        box_ref.ref_count.set(0);
                        drop_in_place(addr_of_mut!(ptr.as_mut().value));
                        dealloc(ptr.as_ptr().cast(), Layout::for_value(ptr.as_ref()));
                    }
                }
            }
        }
    }
}
```

I, being very clever, decided to use a sentinel value of 0 for the reference count when an
allocation is being cleaned up (to prevent spurious double-frees).

However, this code has a problem - how the hell are we supposed to implement `is_accessible`?

## Trait hackery

Our pseudocode for `is_accessible` required us to be able to access the set of edges going out from
a node.
Doing so is kind of hard.
If we were writing this in C, we would scan the allocation on the heap, looking for data that
looked like they could be pointers into other allocations.
In Rust, though, we can be a lot more precise by adding a small constraint onto every
garbage-collected type.

If the garbage collector wasn't enough, we're bringing the visitor pattern over from Java.
We force every garbage-collected value to implement the `Collectable` trait, which will delegate
some `Visitor` to each of its garbage-collected fields.

```rust

pub struct Gc<T: Collectable + ?Sized> {
   // same as before ...
}

pub trait Collectable {
    fn accept<V: Visitor>(&self, visitor: &mut V);
}

pub trait Visitor {
    fn visit_gc<T: Collectable + ?Sized>(&mut self, gc: &Gc<T>)
}
```

For an example implementation, here's how an array might implement it:

```rust
impl<T: Collectable> Collectable for [T] {
    fn accept<V: Visitor>(&self, visitor: &mut V) {
        self.iter().for_each(|elem| elem.accept(visitor));
    }
}
```
